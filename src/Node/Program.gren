module Node.Program exposing
    ( SimpleProgram
    , defineSimple
    , endWithCmd
    --
    , Program
    , ProgramConfiguration
    , define
    , startProgram
    --
    , AppInitTask
    , await
    , awaitTask
    )


{-| A NodeJS program is defined like most other Gren programs, except that
there is more flexibility regarding how it is initialized.

You can initialize any number of subsystems, like `FileSystem` or `Terminal`, before
initializing your own program with the results of those initializations.

As part of initializing a subsystem, you usually also get access to a value that permits
you to contact said subsystem. Be careful what code you give these permissions to.

## Simple Program

@docs SimpleProgram, defineSimple, endWithCmd

## Program

@docs Program, ProgramConfiguration, define, startProgram

## Initialization

@docs AppInitTask, await, awaitTask
-}


import Task exposing (Task)
import Internal.AppInitTask


{-| A simple program that executes a single task and then exits.
-}
type alias SimpleProgram a =
    Program {} a


{-| The definition of a Gren program that runs on NodeJS.
-}
type alias Program model msg =
    Platform.Program {} (Model model) (Msg model msg)


{-| This is like a `Task`, but can only be run as part of initializing your
program. This is usually used for values which should be provided to your program,
and only your program, as opposed to third-party packages.
-}
type alias AppInitTask a =
    Internal.AppInitTask.AppInitTask a


-- TOP LEVEL PROGRAM


type Model model
    = Uninitialized
    | Initialized model


type Msg model msg
    = InitDone { model : model, command : Cmd msg }
    | MsgReceived msg


{-| The required functions that define a program.
-}
type alias ProgramConfiguration model msg =
    { init : AppInitTask { model : model, command : Cmd msg }
    , update : msg -> model -> { model : model, command : Cmd msg }
    , subscriptions : model -> Sub msg
    }


{-| Define a program with access to long-lived state and the ability to respond to
messages and listen to subscriptions. If you want to define a simple and short-lived
program, chances are you're looking for `defineSimple` instead.
-}
define : ProgramConfiguration model msg -> Program model msg
define config =
    Platform.worker
        { init = init config.init
        , update = update config.update
        , subscriptions = subscriptions config.subscriptions
        }


{-| Define a simple program that doesn't require long-lived state or the ability to respond
to messages or subscriptions. Ideal for simple and short-lived programs.
-}
defineSimple : AppInitTask (Cmd a) -> SimpleProgram a
defineSimple (Internal.AppInitTask.AppInitTask task) =
    Platform.worker
        { init = \_ ->
            { model = Uninitialized
            , command = 
                Task.perform 
                    (\cmd -> 
                        InitDone
                            { model = {}
                            , command = cmd
                            }
                    )
                    task
            }
        , update = update (\_ _ -> { model = {}, command = Cmd.none })
        , subscriptions = always Sub.none
        }


init
    : AppInitTask { model : model, command : Cmd msg }
    -> {}
    -> { model : Model model, command : Cmd (Msg model msg) }
init (Internal.AppInitTask.AppInitTask task) {} =
    { model = Uninitialized
    , command = Task.perform InitDone task
    }


update
    : (msg -> model -> { model : model, command : Cmd msg })
    -> Msg model msg
    -> Model model
    -> { model : Model model, command : Cmd (Msg model msg) }
update appUpdate msg model =
    case model of
        Uninitialized ->
            case msg of
                InitDone initResult ->
                    { model = Initialized initResult.model
                    , command = Cmd.map MsgReceived initResult.command
                    }

                MsgReceived _ ->
                    -- Ignore
                    { model = model, command = Cmd.none }

        Initialized appModel ->
            case msg of
                InitDone _ ->
                    -- Ignore
                    { model = model, command = Cmd.none }

                MsgReceived appMsg ->
                    let
                        updateResult =
                            appUpdate appMsg appModel
                    in
                    { model = Initialized updateResult.model
                    , command = Cmd.map MsgReceived updateResult.command
                    }


subscriptions
    : (model -> Sub msg)
    -> (Model model)
    -> Sub (Msg model msg)
subscriptions appSubs model =
    case model of
        Uninitialized ->
            Sub.none

        Initialized appModel ->
            Sub.map MsgReceived (appSubs appModel)


-- APP INIT TASK


{-| This let's you wait for the completion of an `AppInitTask` before either starting
your application, or begin initialization of another `AppInitTask`.

    Program.await Node.initialize <| \nodeConfig ->
    Program.await FileSystem.initialize <| \fileSystemConfig ->
        -- Start your own program with the values from Node and FileSystem
        Program.startProgram
            { model = 1
            , commands = Cmd.none
            }
-}
await : AppInitTask a -> (a -> AppInitTask b) -> AppInitTask b
await (Internal.AppInitTask.AppInitTask task) fn =
    Internal.AppInitTask.AppInitTask (Task.andThen (unwrap << fn) task)


{-| This let's you wait for the completion of a `Task` before either starting
your application, or begin initialization of another `AppInitTask`.

    Program.await Node.initialize <| \nodeConfig ->
    Program.awaitTask Task.now <| \time ->
        -- Start your own program with the values from Node and FileSystem
        Program.startProgram
            { model = time
            , commands = Cmd.none
            }
-}
awaitTask : Task Never a -> (a -> AppInitTask b) -> AppInitTask b
awaitTask task fn =
    Internal.AppInitTask.AppInitTask (Task.andThen (unwrap << fn) task)


unwrap : AppInitTask a -> Task Never a
unwrap (Internal.AppInitTask.AppInitTask task) =
    task


{-| This lets the runtime know that you're done initializing other subsystems,
and that your program is ready to start.
-}
startProgram : { model : model, command : Cmd cmd } -> AppInitTask { model : model, command : Cmd cmd }
startProgram initResult =
    Internal.AppInitTask.AppInitTask (Task.succeed initResult)


{-| When defining a program with `defineTask`, use this function to define the
final command to execute.
-}
endWithCmd : Cmd a -> AppInitTask (Cmd a)
endWithCmd cmd =
    Internal.AppInitTask.AppInitTask (Task.succeed cmd)
