module ChildProcess exposing 
    ( Permission
    , initialize
    --
    , RunOptions
    , defaultRunOptions
    , Shell(..)
    , WorkingDirectory(..)
    , EnvironmentVariables(..)
    , RunDuration(..)
    --
    , FailedRun
    , SuccessfulRun
    , run
    , runWithDefaultOptions
    --
    , SpawnOptions
    , Connection(..)
    , defaultSpawnOptions
    , spawn
    , spawnAndNotifyOnExit
    , spawnWithDefaultOptions
    )


{-| A running program is a process. A process spawned from another process is known as a child process.

This module allow you to spawn child processes.

## Initialization

@docs Permission, initialize

## Running processes

@docs RunOptions, defaultRunOptions, Shell, WorkingDirectory, EnvironmentVariables, RunDuration
@docs FailedRun, SuccessfulRun, run, runWithDefaultOptions

## Spawning processes

@docs SpawnOptions, Connection, defaultSpawnOptions, spawn, spawnWithDefaultOptions, spawnAndNotifyOnExit
-}


import Gren.Kernel.ChildProcess
import Bytes exposing (Bytes)
import Dict exposing (Dict)
import Task exposing (Task)
import Init
import Internal.Init
import Process


{-| This value represents the permission to spawn child processes.

Only code you trust should have access to this value.
-}
type Permission
    = Permission


{-| Initialize the `ChildProcess` subsystem, which gains you the permission to
spawn child processes.
-}
initialize : Init.Task Permission
initialize =
    Task.succeed Permission
        |> Internal.Init.Task


-- OPTIONS


{-| Options to customize the execution of a child process created with [run](#run).

* `shell` is the shell to run the process in (if any)
* `workingDirectory` specifies the working directory of the process
* `environmentVariables` specifies the environment variables the process has access to
* `maximumBytesWrittenToStreams` specifies an upper bound of bytes that can be returned from the process
* `runDuration` specifies a maximum amount of time a process is allowed to run before exiting
-}
type alias RunOptions =
    { shell : Shell
    , workingDirectory : WorkingDirectory
    , environmentVariables : EnvironmentVariables
    , maximumBytesWrittenToStreams : Int
    , runDuration : RunDuration
    }


{-| A nice default set of options for the [run](#run) function
-}
defaultRunOptions : RunOptions
defaultRunOptions =
    { shell = DefaultShell
    , workingDirectory = InheritWorkingDirectory
    , environmentVariables = InheritEnvironmentVariables
    , maximumBytesWrittenToStreams = 1024 * 1024 -- 1Mb
    , runDuration = NoLimit
    }


{-| Which shell should the child process run in?

* `NoShell` executes the process directly, without any shell. A little bit more efficient, but you lose some convinience as shell behaviour (like glob patterns) isn't available for arguments
* `DefaultShell` executes the process in the default shell for the currently running system
* `CustomShell` executes the process in the specified shell.
-}
type Shell
    = NoShell
    | DefaultShell
    | CustomShell String


{-| What should be the working directory of the process?

* `InheritWorkingDirectory` inherits the working directory from its parent
* `SetWorkingDirectory` sets the working directory to the specified value (doesn't affect parent)
-}
type WorkingDirectory
    = InheritWorkingDirectory
    | SetWorkingDirectory String


{-| What should be the environment variables of the process?

* `InheritEnvironmentVariables` inherits the environment variables from its parent
* `MergeWithEnvironmentVariables` inherits the environment variables from its parent, with the specified modifications
* `ReplaceEnvironmentVariables` sets the environment variables to the specified dictionary
-}
type EnvironmentVariables
    = InheritEnvironmentVariables
    | MergeWithEnvironmentVariables (Dict String String)
    | ReplaceEnvironmentVariables (Dict String String)


{-| How long is the process allowed to run before it's forcefully terminated?

* `NoLimit` means it can run forever
* `Milliseconds` sets the limit to the specified number of milliseconds
-}
type RunDuration
    = NoLimit
    | Milliseconds Int


-- RUN


{-| Return value when a process terminates due to an error

The exit code provides some hint of what went wrong, but what it means depends on the program which was run.
-}
type alias FailedRun =
    { exitCode: Int
    , stdout : Bytes
    , stderr : Bytes
    }


{-| Return value when a process terminates without error
-}
type alias SuccessfulRun =
    { stdout : Bytes
    , stderr : Bytes
    }


{-| Execute a process with a given name, arguments and options, and wait for it to terminate.

    run permission "cat" [ "my_file" ] defaultRunOptions

-}
run : Permission -> String -> Array String -> RunOptions -> Task FailedRun SuccessfulRun
run _ program arguments opts =
    Gren.Kernel.ChildProcess.run
        { program = program
        , arguments = arguments
        , shell =
            case opts.shell of
                NoShell ->
                    { choice = 0
                    , value = ""
                    }

                DefaultShell ->
                    { choice = 1
                    , value = ""
                    }

                CustomShell value ->
                    { choice = 2
                    , value = value
                    }
        , workingDirectory =
             case opts.workingDirectory of
                 InheritWorkingDirectory -> 
                    { inherit = True
                    , override = ""
                    }

                 SetWorkingDirectory value ->
                    { inherit = False
                    , override = value
                    }
        , environmentVariables =
            case opts.environmentVariables of
                InheritEnvironmentVariables -> 
                    { option = 0
                    , value = Dict.empty
                    }
                
                MergeWithEnvironmentVariables value ->
                    { option = 1
                    , value = value
                    }

                ReplaceEnvironmentVariables value ->
                    { option = 2
                    , value = value
                    }
        , maximumBytesWrittenToStreams = opts.maximumBytesWrittenToStreams
        , runDuration =
            case opts.runDuration of
                NoLimit ->
                    0

                Milliseconds ms -> 
                    max 0 ms
        }


{-| Same as [run](#run), but with [defaultRunOptions](#defaultRunOptions) passed in as options.
-}
runWithDefaultOptions : Permission -> String -> Array String -> Task FailedRun SuccessfulRun
runWithDefaultOptions permission program arguments =
    run permission program arguments defaultRunOptions


-- SPAWN


{-| Options to customize the execution of a child process created with [spawn](#spawn).

* `shell` is the shell to run the process in (if any)
* `workingDirectory` specifies the working directory of the process
* `environmentVariables` specifies the environment variables the process has access to
* `runDuration` specifies a maximum amount of time a process is allowed to run before exiting
* `connection` let's you specify how close the new process is connected to the application
-}
type alias SpawnOptions =
    { shell : Shell
    , workingDirectory : WorkingDirectory
    , environmentVariables : EnvironmentVariables
    , runDuration : RunDuration
    , connection : Connection
    }


{-| Record expected by spawn kernel call.
-}
type alias SpawnKernelOptions =
    { program : String
    , arguments : Array String
    , shell : 
        { choice : Int
        , value : String 
        }
    , workingDirectory : 
        { inherit : Bool
        , override : String
        }
    , environmentVariables :
        { option : Int
        , value : Dict String String
        }
    , runDuration : Int
    , connection : Int
    }


{-| What relation should the newly spawned process have with the running application?

* `Integrated` means that the spawned process shares the stdin, stdout and stderr streams and that the application will wait for its termination.
* `Ignored` means that stdin, stdout and stderr is seperate but that the application will still wait for its termination.
* `Detached` means that the application can terminate even if the spawned process is still running.
-}
type Connection
    = Integrated
    | Ignored
    | Detached


{-| A nice default set of options for the [spawn](#spawn) function.
-}
defaultSpawnOptions : SpawnOptions
defaultSpawnOptions =
    { shell = DefaultShell
    , workingDirectory = InheritWorkingDirectory
    , environmentVariables = InheritEnvironmentVariables
    , runDuration = NoLimit
    , connection = Integrated
    }


{-| Spawn a process with a given name, arguments and options, and let it run in the background.
This is mostly helpful for starting long-running processes.

    spawn permission "tail" [ "my_file" ] defaultSpawnOptions

-}
spawn : Permission -> String -> Array String -> SpawnOptions -> Task x Process.Id
spawn _ program arguments opts =
    Process.spawn <|
        Gren.Kernel.ChildProcess.spawn <|
            spawnKernelOptions program arguments opts


{-| Spawn a process with a given name, arguments and options, and let it run in the background.
When the process completes, trigger the given message with a `Result [FailedRun](#FailedRun) [SuccessfulRun](#SuccessfulRun)`.

    spawnAndNotifyOnExit permission SleepFinished "sleep" [ "2" ] defaultSpawnOptions 

-}
spawnAndNotifyOnExit : Permission -> (Task FailedRun SuccessfulRun -> msg) -> String -> Array String -> SpawnOptions -> Task x Process.Id
spawnAndNotifyOnExit _ mapper program arguments opts =
    Process.spawn <|
        Gren.Kernel.ChildProcess.spawnAndNotifyOnExit mapper <|
            spawnKernelOptions program arguments opts


spawnKernelOptions : String -> Array String -> SpawnOptions -> SpawnKernelOptions
spawnKernelOptions program arguments opts =
    { program = program
    , arguments = arguments
    , shell =
        case opts.shell of
            NoShell ->
                { choice = 0
                , value = ""
                }

            DefaultShell ->
                { choice = 1
                , value = ""
                }

            CustomShell value ->
                { choice = 2
                , value = value
                }
    , workingDirectory =
         case opts.workingDirectory of
             InheritWorkingDirectory -> 
                { inherit = True
                , override = ""
                }

             SetWorkingDirectory value ->
                { inherit = False
                , override = value
                }
    , environmentVariables =
        case opts.environmentVariables of
            InheritEnvironmentVariables -> 
                { option = 0
                , value = Dict.empty
                }
        
            MergeWithEnvironmentVariables value ->
                { option = 1
                , value = value
                }

            ReplaceEnvironmentVariables value ->
                { option = 2
                , value = value
                }
    , runDuration =
        case opts.runDuration of
            NoLimit ->
                0

            Milliseconds ms -> 
                max 0 ms
    , connection =
        case opts.connection of
            Integrated ->
                0

            Ignored ->
                1

            Detached ->
                2
    }


{-| Same as [spawn], but with [defaultSpawnOptions](#defaultSpawnOptions) passed in as options.
-}
spawnWithDefaultOptions : Permission -> String -> Array String -> Task x Process.Id
spawnWithDefaultOptions permission program arguments =
    spawn permission program arguments defaultSpawnOptions
