effect module HttpClient where { command = MyCmd } exposing
    ( Permission
    , initialize, initializeForHost
    , Request, get, post, request
    , defaultTimeout, withTimeout
    , withHeader, withDuplicatedHeader
    , Body, withEmptyBody, withStringBody, withJsonBody, withBytesBody
    , Expect, expectAnything, expectNothing, expectString, expectJson, expectBytes
    , send
    , Response
    , Error(..), errorToString
    , StreamRequest, StreamEvent(..), stream, sendChunk, startReceive, abort
    )


{-|

A module for communicating over Http.

You start by creating and modifying a `Request` type, which represents the request you'll make to a server. Once done,
you can either do a `send`, which represents the response as a `Task`, or `stream` which will allow you to perform
actions while the request is sending and while the response is coming in. A typical example of why you'd use `stream`
is to show a progress bar to the user, or decode the response incrementally as opposed to all at once.

See [examples/http-client](https://github.com/gren-lang/node/tree/main/examples/http-client) for a working example.

## Initialization

Code that wishes to perform http requests require a permission to do so. Make sure you only grant this permission
to code that you trust.

@docs Permission, initialize, initializeForHost

## Request config

Before sending something over http, you need to configure your request type.

@docs Request, get, post, request

## Timeouts

A timeout represents how long you're willing to wait before giving up on receiving
a response from the server. Servers might not respond for any number of reasons, like bugs or huge amounts of traffic,
so it can be a good idea to return an error to the user instead of waiting "forever" for a response.

@docs defaultTimeout, withTimeout

## Headers

Every http request can have arbitrary metadata attached, called headers. Headers allow you to attach things like
authorization information, how the body is encoded or the name of the client making the request.

@docs withHeader, withDuplicatedHeader

## Request body

The request body is the actual data that you wish to send to a server.

@docs Body, withEmptyBody, withStringBody, withJsonBody, withBytesBody

## Expected response body

Once a request has been sent, you usually get a response. The `Expect` type represents
what we expect the response body to be.

@docs Expect, expectAnything, expectNothing, expectString, expectJson, expectBytes

## Send

Once your `Response` is configured, you want to actually send the request.

@docs send

@docs Response

## Errors

@docs Error, errorToString

## Streaming

Streaming is the more advanced way to perform a http request. This requires that you follow the Elm
architecture, as you'll receive messages for every chunk of data sent and received. The benefit of this
extra complexity, is that you can perform actions while the request is being performed.

@docs StreamRequest, StreamEvent, stream, sendChunk, startReceive, abort

-}


import Dict exposing (Dict)
import Init
import Internal.Init
import Json.Encode as Json
import Json.Decode
import Bytes exposing (Bytes)
import Task exposing (Task)
import Platform
import Gren.Kernel.HttpClient


{-|
-}
type Permission
    = AnyPermission
    | SpecificPermission String


{-|
-}
initialize : Init.Task Permission
initialize =
    Task.succeed AnyPermission
        |> Internal.Init.Task


{-|
-}
initializeForHost : String -> Init.Task Permission
initializeForHost host =
    Task.succeed (SpecificPermission host)
        |> Internal.Init.Task


-- REQUEST CONFIG


{-|
-}
type alias Request a =
    { method : String
    , url : String
    , headers : Dict String (Array String)
    , body : Body
    , expect : Expect a
    , timeout : Int
    }


{-|
-}
get : String -> Request {}
get url =
    request "GET" url


{-|
-}
post : String -> Request {}
post url =
    request "POST" url


{-|
-}
request : String -> String -> Request {}
request method url =
    { method = method
    , url = url
    , headers = Dict.empty
    , body = BodyEmpty
    , expect = ExpectAnything
    , timeout = defaultTimeout
    }


{-|
-}
defaultTimeout : Int
defaultTimeout =
    -- 10 seconds
    10 * 1000


{-|
-}
withTimeout : Int -> Request a -> Request a
withTimeout ms req =
    if ms < 0 then
        req

    else
        { req | timeout = ms }


{-|
-}
withHeader : String -> String -> Request a -> Request a
withHeader key value req =
    { req
        | headers = Dict.insert key [value] req.headers
    }


{-|
-}
withDuplicatedHeader : String -> String -> Request a -> Request a
withDuplicatedHeader key value req =
    { req
        | headers = Dict.update 
            key 
            (Maybe.map (Array.pushLast value) >> Maybe.withDefault [value] >> Just)
            req.headers
    }


-- BODY


{-|
-}
type Body
    = BodyEmpty
    | BodyString String
    | BodyBytes Bytes


bodyTypeAsString : Body -> String
bodyTypeAsString body =
    case body of
        BodyEmpty ->
            "EMPTY"

        BodyString _ ->
            "STRING"

        BodyBytes _ ->
            "BYTES"


{-|
-}
withEmptyBody : String -> Request a -> Request a
withEmptyBody value req = 
    { req
        | headers = Dict.remove "Content-Type" req.headers
        , body = BodyEmpty
    }


{-|
-}
withStringBody : String -> String -> Request a -> Request a
withStringBody mimeType value req = 
    { req
        | headers = Dict.insert "Content-Type" [mimeType] req.headers
        , body = BodyString value
    }


{-|
-}
withJsonBody : Json.Value -> Request a -> Request a
withJsonBody value req = 
    withStringBody "application/json" (Json.encode 0 value) req


{-|
-}
withBytesBody : String -> Bytes -> Request a -> Request a
withBytesBody mimeType value req = 
    { req
        | headers = Dict.insert "Content-Type" [mimeType] req.headers
        , body = BodyBytes value
    }


-- EXPECT


{-|
-}
type Expect a
    = ExpectNothing
    | ExpectAnything
    | ExpectString
    | ExpectJson (Json.Decode.Decoder a)
    | ExpectBytes


expectTypeAsString : Expect a -> String
expectTypeAsString expect =
    case expect of
        ExpectNothing ->
            "NOTHING"

        ExpectAnything ->
            "ANYTHING"

        ExpectString ->
            "STRING"

        ExpectJson _ ->
            "JSON"

        ExpectBytes ->
            "BYTES"


{-|
-}
expectAnything : Request a -> Request {}
expectAnything req =
    -- Need to create a new record for type checking to pass
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectAnything
    , timeout = req.timeout
    }


{-|
-}
expectNothing : Request a -> Request {}
expectNothing req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectNothing
    , timeout = req.timeout
    }


{-|
-}
expectString : Request a -> Request String
expectString req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectString
    , timeout = req.timeout
    }


{-|
-}
expectJson : Json.Decode.Decoder a -> Request x -> Request a
expectJson decoder req = 
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectJson decoder
    , timeout = req.timeout
    }


{-|
-}
expectBytes : Request a -> Request Bytes
expectBytes req =
    { method = req.method
    , url = req.url
    , headers = req.headers
    , body = req.body
    , expect = ExpectBytes
    , timeout = req.timeout
    }


-- SIMPLE SEND


{-|
-}
send
    : Permission 
    -> Request a
    -> Task Error (Response a)
send permission config =
    Gren.Kernel.HttpClient.request (kernelRequestConfig permission config)


type alias KernelRequestConfig a =
    { method : String
    , url : String
    , headers : Dict String (Array String)
    , bodyType : String
    , body : Body
    , expectType : String
    , expect : Expect a
    , timeout : Int
    }


kernelRequestConfig : Permission -> Request a -> KernelRequestConfig a
kernelRequestConfig permission config =
    let
        actualUrl =
            case permission of
                AnyPermission ->
                    config.url

                SpecificPermission prefix ->
                    prefix ++ config.url
    in
    { method = config.method
    , url = actualUrl
    , headers = config.headers
    , bodyType = bodyTypeAsString config.body
    , body = config.body
    , expectType = expectTypeAsString config.expect
    , expect = config.expect
    , timeout = config.timeout
    }


-- RESPONSE


{-|
-}
type alias Response data =
    { statusCode : Int
    , statusText : String
    , headers : Dict String (Array String)
    , data : data
    }


-- ERRORS


{-|
-}
type Error 
    = BadUrl String
    | BadStatus (Response String)
    | Timeout
    | UnknownError String


{-|
-}
errorToString : Error -> String
errorToString err =
    case err of
        Timeout ->
            "Timeout"

        BadUrl url ->
            "Bad URL: " ++ url

        BadStatus res ->
            "Bad status: " ++ String.fromInt res.statusCode

        UnknownError debugStr ->
            "Unknown error: " ++ debugStr


-- STREAM


{-|
-}
type StreamRequest =
    StreamRequest Int


{-|
-}
type StreamEvent
    = SentChunk StreamRequest
    | ReceivedChunk StreamRequest (Response Bytes)
    | Error Error
    | Aborted
    | Done


{-|
-}
stream : Permission -> (StreamEvent -> msg) -> Request Bytes -> Cmd msg
stream permission toMsg config =
    command <| Start toMsg <| kernelRequestConfig permission config


{-|
-}
sendChunk : StreamRequest -> Bytes -> Cmd msg
sendChunk req bytes =
    command <| SendChunk bytes req


{-|
-}
startReceive : StreamRequest -> Cmd msg
startReceive req =
    command <| StartReceive req


{-|
-}
abort : StreamRequest -> Cmd a
abort req =
    command <| Abort req


-- COMMANDS


type MyCmd msg
    = Start (StreamEvent -> msg) (KernelRequestConfig Bytes)
    | SendChunk Bytes StreamRequest
    | StartReceive StreamRequest
    | Abort StreamRequest


cmdMap : (a -> b) -> MyCmd a -> MyCmd b
cmdMap func cmd =
    case cmd of
        Start toMsg req ->
            Start (toMsg >> func) req

        SendChunk bytes req ->
            SendChunk bytes req
        
        StartReceive req ->
            StartReceive req

        Abort req ->
            Abort req


type alias RequestsState msg =
    { nextId : Int 
    , msgHandlers : Dict Int { toMsg : (StreamEvent -> msg), kernelRequest : KernelRequest }
    }


type KernelRequest = 
    -- Actual implementation provided by kernel code
    KernelRequest


init : Task Never (RequestsState msg)
init =
  Task.succeed
    { nextId = 0
    , msgHandlers = Dict.empty
    }


onEffects : Platform.Router msg SelfMsg -> Array (MyCmd msg) -> RequestsState msg -> Task Never (RequestsState msg)
onEffects router commands state =
  case Array.popFirst commands of
    Nothing ->
      Task.succeed state

    Just { first, rest } ->
        case first of
            Start toMsg config ->
                let
                    streamingReq =
                        StreamRequest state.nextId
                in
                Gren.Kernel.HttpClient.stream 
                    (Platform.sendToSelf router << Cleanup) 
                    (Platform.sendToApp router << toMsg) 
                    streamingReq 
                    config
                    |> Task.map 
                        (\kernelRequest -> 
                            { state 
                                | nextId = state.nextId + 1
                                , msgHandlers = 
                                    Dict.insert 
                                        state.nextId
                                        { toMsg = toMsg
                                        , kernelRequest = kernelRequest
                                        }
                                        state.msgHandlers
                            }
                        )
                    |> Task.andThen (\updatedState -> onEffects router rest updatedState)

            SendChunk bytes ((StreamRequest reqId) as req) ->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.sendChunk 
                            (Platform.sendToApp router << msgHandler.toMsg) 
                            msgHandler.kernelRequest
                            req 
                            bytes
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state
            
            StartReceive ((StreamRequest reqId) as req)->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.startReceive
                            (Platform.sendToSelf router << Cleanup)
                            (Platform.sendToApp router << msgHandler.toMsg) 
                            msgHandler.kernelRequest
                            req 
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state

            Abort (StreamRequest reqId)->
                case Dict.get reqId state.msgHandlers of
                    Just msgHandler ->
                        Gren.Kernel.HttpClient.abort msgHandler.kernelRequest
                            |> Task.andThen (\_ -> onEffects router rest state)
                    
                    Nothing ->
                        onEffects router rest state
                

type SelfMsg
    = Cleanup StreamRequest


onSelfMsg : Platform.Router msg SelfMsg -> SelfMsg -> RequestsState msg -> Task Never (RequestsState msg)
onSelfMsg _ event state =
    case event of
        Cleanup (StreamRequest reqId) ->
            Task.succeed 
                { state | msgHandlers = Dict.remove reqId state.msgHandlers }
